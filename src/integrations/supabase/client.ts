
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { Task, Alert, PrioritizedTask, EfficiencyMetrics, TaskCompletionRate, PriorityFactors } from '@/types/flow';

const SUPABASE_URL = "https://yvtjimbvpuclcgvnmvyh.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl2dGppbWJ2cHVjbGNndm5tdnloIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIwMDYzMTksImV4cCI6MjA1NzU4MjMxOX0.VnjEht3dkgBV94NbyISAabrRq4tyW04X8fZ_dvdNBrM";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Service functions for SPACE system

// Project Services
export const getProjects = async () => {
  const { data, error } = await supabase
    .from('projects')
    .select('*')
    .order('created_at', { ascending: false });
    
  if (error) throw error;
  return data;
};

export const getProject = async (id: string) => {
  const { data, error } = await supabase
    .from('projects')
    .select('*')
    .eq('id', id)
    .single();
    
  if (error) throw error;
  return data;
};

export const createProject = async (project: { name: string; description?: string; user_id: string }) => {
  const { data, error } = await supabase
    .from('projects')
    .insert(project)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// Goal Services
export const getGoals = async (projectId: string) => {
  const { data, error } = await supabase
    .from('goals')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false });
    
  if (error) throw error;
  return data;
};

export const createGoal = async (goal: { 
  project_id: string; 
  title: string; 
  description?: string;
  status?: string;
  priority?: string;
  due_date?: string;
}) => {
  const { data, error } = await supabase
    .from('goals')
    .insert(goal)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

export const updateGoal = async (id: string, updates: {
  title?: string;
  description?: string;
  status?: string;
  priority?: string;
  due_date?: string;
}) => {
  const { data, error } = await supabase
    .from('goals')
    .update(updates)
    .eq('id', id)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// Resource Services
export const getResources = async (projectId: string) => {
  const { data, error } = await supabase
    .from('resources')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false });
    
  if (error) throw error;
  return data;
};

export const createResource = async (resource: {
  project_id: string;
  name: string;
  type: string;
  quantity?: number;
  availability?: string;
  allocation_details?: string;
}) => {
  const { data, error } = await supabase
    .from('resources')
    .insert(resource)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// Timeline Services
export const getTimelineEvents = async (projectId: string) => {
  const { data, error } = await supabase
    .from('timeline_events')
    .select('*')
    .eq('project_id', projectId)
    .order('start_date', { ascending: true });
    
  if (error) throw error;
  return data;
};

export const createTimelineEvent = async (event: {
  project_id: string;
  title: string;
  description?: string;
  start_date: string;
  end_date: string;
  status?: string;
}) => {
  const { data, error } = await supabase
    .from('timeline_events')
    .insert(event)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// Metrics Services
export const getMetrics = async (projectId: string) => {
  const { data, error } = await supabase
    .from('metrics')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false });
    
  if (error) throw error;
  return data;
};

export const createMetric = async (metric: {
  project_id: string;
  name: string;
  description?: string;
  target?: number;
  current_value?: number;
  unit?: string;
}) => {
  const { data, error } = await supabase
    .from('metrics')
    .insert(metric)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

export const updateMetric = async (id: string, updates: {
  name?: string;
  description?: string;
  target?: number;
  current_value?: number;
  unit?: string;
}) => {
  const { data, error } = await supabase
    .from('metrics')
    .update(updates)
    .eq('id', id)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// AI Suggestions Services
export const getAiSuggestions = async (projectId: string) => {
  const { data, error } = await supabase
    .from('ai_suggestions')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false });
    
  if (error) throw error;
  return data;
};

export const markSuggestionImplemented = async (id: string, isImplemented: boolean = true) => {
  const { data, error } = await supabase
    .from('ai_suggestions')
    .update({ is_implemented: isImplemented })
    .eq('id', id)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// Trigger scheduled tasks manually (for demonstration purposes)
export const generateInsights = async () => {
  const { data, error } = await supabase
    .rpc('generate_project_insights');
    
  if (error) throw error;
  return data;
};

export const updateMetricsFromGoals = async () => {
  const { data, error } = await supabase
    .rpc('update_metrics_from_goals');
    
  if (error) throw error;
  return data;
};

// Task Management Services
export const getTasks = async (projectId: string): Promise<Task[]> => {
  try {
    const { data, error } = await supabase
      .from('tasks')
      .select('*')
      .eq('project_id', projectId)
      .order('created_at', { ascending: false });
      
    if (error) {
      if (error.code === "42P01") { // relation "tasks" does not exist
        console.warn("Tasks table doesn't exist, returning mock data");
        return [
          {
            id: "mock-1",
            project_id: projectId,
            title: "Create project plan",
            description: "Outline the project scope, timeline, and resource requirements",
            status: "completed",
            priority: "high",
            due_date: new Date(Date.now() + 1000 * 60 * 60 * 24 * 3).toISOString(),
            assigned_to: "Sarah Johnson",
            created_at: new Date().toISOString()
          },
          {
            id: "mock-2",
            project_id: projectId,
            title: "Design user interface",
            description: "Create wireframes and design mockups for the application",
            status: "in_progress",
            priority: "medium",
            due_date: new Date(Date.now() + 1000 * 60 * 60 * 24 * 5).toISOString(),
            assigned_to: "Michael Chen",
            created_at: new Date().toISOString()
          },
          {
            id: "mock-3",
            project_id: projectId,
            title: "Implement backend API",
            description: "Develop RESTful API endpoints for the application",
            status: "pending",
            priority: "high",
            due_date: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString(),
            assigned_to: "David Kim",
            created_at: new Date().toISOString()
          }
        ] as Task[];
      }
      throw error;
    }
    return data || [];
  } catch (error) {
    console.error('Error fetching tasks:', error);
    return [] as Task[];
  }
};

export const createTask = async (task: {
  project_id: string;
  title: string;
  description?: string;
  status?: string;
  priority?: string;
  due_date?: string | null;
  assigned_to?: string | null;
}): Promise<Task> => {
  try {
    const { data, error } = await supabase
      .from('tasks')
      .insert(task)
      .select()
      .single();
      
    if (error) {
      if (error.code === "42P01") { // relation "tasks" does not exist
        console.warn("Tasks table doesn't exist, returning mock data");
        return {
          id: `mock-${Date.now()}`,
          ...task,
          description: task.description || null,
          status: task.status || "pending",
          priority: task.priority || "medium",
          due_date: task.due_date || null,
          assigned_to: task.assigned_to || null,
          created_at: new Date().toISOString()
        } as Task;
      }
      throw error;
    }
    return data;
  } catch (error) {
    console.error('Error creating task:', error);
    // Return mock data as fallback
    return {
      id: `mock-${Date.now()}`,
      ...task,
      description: task.description || null,
      status: task.status || "pending",
      priority: task.priority || "medium",
      due_date: task.due_date || null,
      assigned_to: task.assigned_to || null,
      created_at: new Date().toISOString()
    } as Task;
  }
};

export const updateTaskStatus = async (taskId: string, status: string): Promise<Task> => {
  try {
    const { data, error } = await supabase
      .from('tasks')
      .update({ status })
      .eq('id', taskId)
      .select()
      .single();
      
    if (error) {
      if (error.code === "42P01") { // relation "tasks" does not exist
        console.warn("Tasks table doesn't exist, returning mock data");
        return {
          id: taskId,
          status,
          title: "Mock Task",
          description: null,
          priority: "medium",
          due_date: null,
          assigned_to: null,
          project_id: "",
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        } as Task;
      }
      throw error;
    }
    return data;
  } catch (error) {
    console.error('Error updating task status:', error);
    // Return mock data as fallback
    return {
      id: taskId,
      status,
      title: "Mock Task",
      description: null,
      priority: "medium",
      due_date: null,
      assigned_to: null,
      project_id: "",
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    } as Task;
  }
};

// Efficiency Analysis Services
export const getProjectEfficiency = async (projectId: string): Promise<EfficiencyMetrics> => {
  // In a real implementation, this would call the database
  // For now, return mock data for demonstration
  return {
    completionRate: 78,
    resourceUtilization: 85,
    avgTaskDuration: 3.5
  };
};

export const getTasksCompletionRate = async (projectId: string): Promise<TaskCompletionRate> => {
  // In a real implementation, this would calculate from tasks table
  // For now, return mock data for demonstration
  return {
    rate: 78,
    total: 50,
    completed: 39
  };
};

// Alert System Services
export const getProjectAlerts = async (projectId: string): Promise<Alert[]> => {
  try {
    const { data, error } = await supabase
      .from('alerts')
      .select('*')
      .eq('project_id', projectId)
      .order('created_at', { ascending: false });
      
    if (error) {
      if (error.code === "42P01") { // relation "alerts" does not exist
        console.warn("Alerts table doesn't exist, returning mock data");
        // Return mock alerts
        return [
          {
            id: '1',
            title: 'Resource bottleneck detected',
            description: 'Design team is over-allocated for the next sprint, which might delay project delivery',
            type: 'critical',
            created_at: new Date(Date.now() - 1000 * 60 * 60).toISOString(),
            is_read: false,
            source: 'Resource Allocation',
            project_id: projectId,
          },
          {
            id: '2',
            title: 'Task deadline approaching',
            description: 'The "Create UI wireframes" task is due in 24 hours with no progress update',
            type: 'warning',
            created_at: new Date(Date.now() - 1000 * 60 * 180).toISOString(),
            is_read: false,
            source: 'Task Management',
            project_id: projectId,
          },
          {
            id: '3',
            title: 'Performance decline detected',
            description: 'Task completion rate has dropped by 15% in the last week',
            type: 'warning',
            created_at: new Date(Date.now() - 1000 * 60 * 360).toISOString(),
            is_read: true,
            source: 'Performance Metrics',
            project_id: projectId,
          },
          {
            id: '4',
            title: 'New team member added',
            description: 'Sarah Johnson has been added to the project team',
            type: 'info',
            created_at: new Date(Date.now() - 1000 * 60 * 720).toISOString(),
            is_read: true,
            source: 'Team Management',
            project_id: projectId,
          }
        ] as Alert[];
      }
      throw error;
    }
    return data || [];
  } catch (error) {
    console.error('Error fetching alerts:', error);
    // Return empty array as fallback
    return [];
  }
};

export const dismissAlert = async (alertId: string): Promise<Alert> => {
  try {
    const { data, error } = await supabase
      .from('alerts')
      .update({ is_read: true })
      .eq('id', alertId)
      .select()
      .single();
      
    if (error) {
      if (error.code === "42P01") { // relation "alerts" does not exist
        console.warn("Alerts table doesn't exist, returning mock data");
        return {
          id: alertId,
          is_read: true,
          title: "Mock Alert",
          description: "",
          type: "info",
          source: "System",
          project_id: "",
          created_at: new Date().toISOString()
        } as Alert;
      }
      throw error;
    }
    return data;
  } catch (error) {
    console.error('Error dismissing alert:', error);
    // Return mock data as fallback
    return {
      id: alertId,
      is_read: true,
      title: "Mock Alert",
      description: "",
      type: "info",
      source: "System",
      project_id: "",
      created_at: new Date().toISOString()
    } as Alert;
  }
};

// Task Prioritization Services
export const getPrioritizedTasks = async (projectId: string): Promise<PrioritizedTask[]> => {
  try {
    const { data, error } = await supabase
      .from('prioritized_tasks')
      .select(`
        *,
        tasks:task_id (*)
      `)
      .eq('project_id', projectId)
      .order('priority_score', { ascending: false });
      
    if (error) {
      if (error.code === "42P01") { // relation "prioritized_tasks" does not exist
        console.warn("Prioritized tasks table doesn't exist, returning mock data");
        
        // Get regular tasks and add priority scores
        const tasks = await getTasks(projectId);
        const prioritizedTasks: PrioritizedTask[] = tasks.map((task, index) => {
          const priorityMap: Record<string, number> = { 
            high: 80 + Math.random() * 20, 
            medium: 50 + Math.random() * 30, 
            low: 20 + Math.random() * 30 
          };
          
          const baseScore = priorityMap[task.priority] || 50;
          const deadlineFactor = task.due_date ? 
            Math.max(0, 100 - (new Date(task.due_date).getTime() - Date.now()) / (1000 * 60 * 60 * 24) * 10) : 50;
          
          return {
            ...task,
            priority_score: Math.round(baseScore),
            deadline_factor: Math.round(deadlineFactor),
            impact_factor: Math.round(Math.random() * 100),
            effort_factor: Math.round(Math.random() * 100),
            complexity_factor: Math.round(Math.random() * 100),
            dependencies_factor: Math.round(Math.random() * 100)
          };
        });
        
        return prioritizedTasks;
      }
      throw error;
    }
    
    // Transform data to match PrioritizedTask interface
    if (data) {
      return data.map(item => ({
        ...item.tasks,
        priority_score: item.priority_score,
        deadline_factor: item.deadline_factor,
        impact_factor: item.impact_factor,
        effort_factor: item.effort_factor,
        complexity_factor: item.complexity_factor,
        dependencies_factor: item.dependencies_factor
      }));
    }
    
    return [];
  } catch (error) {
    console.error('Error fetching prioritized tasks:', error);
    // Return empty array as fallback
    return [];
  }
};

export const setPriorityFactors = async (projectId: string, factors: PriorityFactors): Promise<{
  success: boolean;
  projectId: string;
  factors: PriorityFactors;
}> => {
  // In a real implementation, this would update the priority factors in the database
  // For now, just log and return mock success data
  console.log('Setting priority factors for project', projectId, factors);
  return {
    success: true,
    projectId,
    factors
  };
};
